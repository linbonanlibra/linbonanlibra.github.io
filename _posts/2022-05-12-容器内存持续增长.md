---
title: 模型服务器内存持续下降问题排查
date: 2022-05-12 18:06:00 +0800
categories: [Note]
tags: [Memory, note]     # TAG names should always be lowercase
---

## 尝试用 valgrind 分析内存
考虑先尝试定位出 Native 内存到底被什么占用了、是什么申请了内存却没及时释放，最初想用 valgrind 抓一下内存的分配/释放动作，来分析是什么被遗留在了内存里没释放。
但在机器上安装好环境后发现，它要有一个可执行文件才比较便于分析，对于 jvm，它不太好使用。但脱离了jvm，单独把模型加载代码抽出来又感觉不能很好的还原场景。
``` shell
yum install valgrind
valgrind --leak-check=full --show-leak-kinds=all --suppressions=suppression_file --log-file=valgrind_with_suppression.log -v java <Java Class>
valgrind --leak-check=full --show-leak-kinds=all -v java
```

## 尝试用 jemalloc 分析内存
另一个思路是，尝试将内存分配管理交给jemalloc来做，因为它自带一个prof工具，可以分析内存情况。
参考 https://chenhm.com/post/2018-12-05-debuging-java-memory-leak 和 20210409 kms server内存占用高

在测试机器上安装环境，尝试如下配置后重启机器
``` shell
export LD_PRELOAD=/usr/lib64/libjemalloc.so
export MALLOC_CONF=prof:true,lg_prof_sample:1,lg_prof_interval:26,prof_prefix:/opt/logs/com.sankuai.qcs.service.modelserver/heap/jeprof.out
./jeprof --show_bytes -svg /usr/local/java/bin/java  /jeprof.*.heap > ms-jeprof.svg
```
启动时的 heap dump prof 图如下，没看到明显的来自jvm的大占用，反倒是启动后直接把 mem.free.percent 打到 20%了，触发多次模型重载后甚至导致机器 OOM
![img](/assets/img/attachments/modelserverHeapDump.png)
里怀疑是 prof 的参数配置的有问题，导致监控成本过高，损害了系统运行(yum install 时是无法开启prof的，要靠源码手动编译时增加参数来开启prof能力，因此怀疑这个功能对性能影响会比较大？)。
虽然尝试变更了几次 prof参数都没能抓到理想的 dump 数据，但在了解 jemalloc 时有了一个新思路，会不会是 glibc 的内存管理特点，导致了内存没被及时还给系统？

## glibc 内存碎片
查了一些关于 glibc 内存分配的介绍，越发怀疑可能是内存碎片的问题。

> 进程向 OS 申请和释放地址空间的接口 sbrk/mmap/munmap 都是系统调用，频繁调用系统调用都比较消耗系统资源的。而且， mmap 申请的内存被 munmap 后，从新申请会产生更多的缺页中断。例如使用 mmap 分配 1M 空间，第一次调用产生了大量缺页中断 (1M/4K 次 ) ，当munmap 后再次分配 1M 空间，会再次产生大量缺页中断。缺页中断是内核行为，会致使内核态CPU消耗较大。另外，若是使用 mmap 分配小内存，会致使地址空间的分片更多，内核的管理负担更大。 
同时堆是一个连续空间，而且堆内碎片因为没有归还 OS ，若是可重用碎片，再次访问该内存极可能不需产生任何系统调用和缺页中断，这将大大下降 CPU 的消耗。 所以， glibc 的 malloc 实现中，充分考虑了 sbrk 和 mmap 行为上的差别及优缺点，默认分配大块内存 (128k) 才使用 mmap 得到地址空间，也可经过 mallopt(M_MMAP_THRESHOLD, <SIZE>) 来修改这个临界值。

还在 openjdk 里翻到了一个关于「通过 jcmd命令主动触发trim内存」(收缩内存？)的讨论 https://bugs.openjdk.java.net/browse/JDK-8269345

看了下他们最终对该指令的代码实现 https://github.com/openjdk/jdk17u/commit/d93500168cd120165fedb9609fdf2e10458976dd?diff=split, 可以看到命令的实现方法在下图，而这个方法里，除去执行前后的信息统计，真正的逻辑只有一句，malloc_trim(0)。
![img](/assets/img/attachments/malloc_trim_source_code.png)
这是 Glibc 的一个方法 https://github.com/lattera/glibc/blob/master/malloc/malloc.h
![img](/assets/img/attachments/glibc_malloc_trim.png)

在测试机器上先重复加载模型，让 mem.free.percent 出现明显下跌，然后登陆机器，切换到 root 权限后 执行 sudo gdb -p 5331 -batch -ex 'call malloc_trim(0)'  ，通过gdb来调用一次 malloc_trim 函数。
反复几次，可以看到每次执行trim函数后，内存都会明显得到释放。至此，大概率确定是 glibc 内存分配策略下，内存碎片导致的问题

## 临时解决方案
考虑通过 jni 的方式实现在 jvm 内主动调用 malloc_trim 函数实现对C库缓存的内存的回收。由于我们除了调用该函数外并不需要增加其他自定义的逻辑，因此可以考虑直接利用 JNA 实现。
```
glic 2.7 malloc.c 源码 https://elixir.bootlin.com/glibc/glibc-2.17/source/malloc/malloc.c 
glic 2.7 malloc.h https://github.com/apc-llc/glibc-2.17/blob/master/malloc/malloc.h
jna 源码 https://github.com/java-native-access/jna
jna 示例 https://www.eshayne.com/jnaex/index.html?example=4
```

``` java
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.Structure;

public interface GLibcLibrary extends Library {

    static GLibcLibrary INSTANCE = Native.loadLibrary("libc.so.6", GLibcLibrary.class);

    /**
      @see https://elixir.bootlin.com/glibc/glibc-2.17/source/malloc/malloc.c
      malloc_trim(size_t pad);

      If possible, gives memory back to the system (via negative
      arguments to sbrk) if there is unused memory at the `high' end of
      the malloc pool. You can call this after freeing large blocks of
      memory to potentially reduce the system-level memory requirements
      of a program. However, it cannot guarantee to reduce memory. Under
      some allocation patterns, some large free blocks of memory will be
      locked between two used chunks, so they cannot be given back to
      the system.

      The `pad' argument to malloc_trim represents the amount of free
      trailing space to leave untrimmed. If this argument is zero,
      only the minimum amount of memory to maintain internal data
      structures will be left (one page or less). Non-zero arguments
      can be supplied to maintain enough trailing space to service
      future expected allocations without having to re-obtain memory
      from the system.

      Malloc_trim returns 1 if it actually released any memory, else 0.
      On systems that do not support "negative sbrks", it will always
      return 0.
    */
    int malloc_trim(int size);

    /**
     * @see https://elixir.bootlin.com/glibc/glibc-2.17/source/malloc/malloc.c
     * struct mallinfo __libc_mallinfo(void);
     *
     * Returns (by copy) a struct containing various summary statistics
     */
    MallInfo.ByValue mallinfo();
}

/**
 * 是 glibc malloc.h 中定义的 mallinfo struct 映射的 java 结构
 */
public class MallInfo extends Structure {

    public static class ByValue extends MallInfo implements Structure.ByValue {

        public ByValue() {
        }

        public String stats() {
            return "===========================================================================\n" +
                    "Arena Total Size:                " + arena / 1024 + " Kib\n" +
                    "Arena Used Size:                 " + uordblks / 1024 + " Kib\n" +
                    "Arena Free Size:                 " + fordblks / 1024 + " Kib\n" +
                    "Arena Reclaimable Size:          " + keepcost / 1024 + " Kib\n" +
                    "Arena Free Blocks Count:         " + ordblks + "\n" +
                    "FastBin Blocks Count:            " + smblks + "\n" +
                    "FastBin Blocks Total Size :      " + fsmblks / 1024 + "\n" +
                    "Mapped Blocks Count:             " + hblks + "\n" +
                    "Mapped Blocks Total Size:        " + hblkhd / 1024 + " Kib\n" +
                    "Total C Heap Size:               " + (arena / 1024 + hblkhd / 1024) + " Kib\n" +
                    "注: 因历史原因, mallinfo 中的指标都是int类型, 可能因数值越界而不不准确, 仅供参考"+
                    "===========================================================================";
        }
    }

    // current total non-mmapped bytes allocated from system
    public int arena;

    // the number of free chunks
    public int ordblks;  /* number of free chunks */

    // the number of fastbin blocks (i.e., small chunks that have been freed but not use resused or consolidated)
    public int smblks;

    // current number of mmapped regions
    public int hblks;

    // total bytes held in mmapped regions
    public int hblkhd;

    // the maximum total allocated space. This will be greater than current total if trimming has occurred.
    public int usmblks;

    // total bytes held in fastbin blocks
    public int fsmblks;

    // current total allocated space (normal or mmapped)
    public int uordblks;

    // total free space
    public int fordblks;

    // the maximum number of bytes that could ideally be released
    // back to system via malloc_trim. ("ideally" means that
    // it ignores page restrictions etc.)
    public int keepcost;

    public MallInfo() {
    }

    @Override
    protected List<String> getFieldOrder() {
        return Lists.newArrayList("arena", "ordblks", "smblks", "hblks", "hblkhd", "usmblks", "fsmblks", "uordblks", "fordblks", "keepcost");
    }
}
```
